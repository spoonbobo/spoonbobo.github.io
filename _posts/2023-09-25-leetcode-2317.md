---
title: "Leetcode 2317: Maximizing XOR"
date: 2023-09-25
layout: post
---

Problem description: You are given a 0-indexed integer array nums. In one operation, select any non-negative integer x and an index i, then update nums[i] to be equal to nums[i] AND (nums[i] XOR x). Note that AND is the bitwise AND operation and XOR is the bitwise XOR operation. Return the maximum possible bitwise XOR of all elements of nums after applying the operation any number of times.

To complete this question, let's recall these 2 facts:
1. `XOR` is maximised when two binary numbers have largest number of pairs of `1` and `0`.

For example, `1110` (14) XOR `1110` (14) would give you 0, whilst `1110` and `0001` would give you 15.

2. Let's think abcout this statement deeply: `In one operation, select any non-negative integer x and an index i, then update nums[i] to be equal to nums[i] AND (nums[i] XOR x)`, notice `x` can be any arbitrary number of our choice. To maximise `XOR`, we will have to make use of this and transform `nums[i]` in a way such that our `XOR` operations are maximised.

Let's elaborate this statement using an example input: `[4, 8, 1, 6]` and write these numbers in binary-matrix form:

$$
\begin{matrix}
0 & 1 & 0 & 0\\
1 & 0 & 0 & 0\\
0 & 0 & 0 & 1\\
0 & 1 & 1 & 0
\end{matrix}
$$

